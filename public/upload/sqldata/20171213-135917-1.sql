-- -----------------------------
-- Think MySQL Data Transfer 
-- 
-- Host     : 
-- Port     : 
-- Database : 
-- 
-- Part : #1
-- Date : 2017-12-13 13:59:17
-- -----------------------------

SET FOREIGN_KEY_CHECKS = 0;


-- -----------------------------
-- Table structure for `run_article`
-- -----------------------------
DROP TABLE IF EXISTS `run_article`;
CREATE TABLE `run_article` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `cat_id` int(11) DEFAULT NULL,
  `title` varchar(80) DEFAULT NULL,
  `author` varchar(80) NOT NULL,
  `description` varchar(80) DEFAULT NULL COMMENT '描述',
  `content` text,
  `images` text,
  `is_show` int(5) NOT NULL,
  `add_time` date DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=MyISAM AUTO_INCREMENT=19 DEFAULT CHARSET=utf8;

-- -----------------------------
-- Records of `run_article`
-- -----------------------------
INSERT INTO `run_article` VALUES ('9', '15', '你离开以后 我活成了你的样子。', 'MR:DALY', 'True love doesn\'t mean being inseparable. It means being separated。。。', '', '', '1', '2017-11-22');
INSERT INTO `run_article` VALUES ('10', '14', '那一年', 'MR:DALY', '在历史的长流中，和有限的生命里，能拥有一段美好的回忆。是一件多么庆辛的事', '在毕业后的一段时间里几乎痛苦伴随着我一路走过来的，所以对待一些适合物，就多了一下包容，相泯一笑就过了', '', '1', '2017-11-22');
INSERT INTO `run_article` VALUES ('11', '17', '今天的任务是理解什么事红黑树', 'MR:DALY', '红黑树 是一种自平衡二叉查找树，在了解数据结构之前需要深入了解指针，递归。', '<ul class=\"lemmaWgt-lemmaTitle lemmaWgt-lemmaTitle- list-paddingleft-2\"><li class=\"lemmaWgt-lemmaTitle-title\"><h1>红黑树</h1><p><a class=\"edit-lemma cmn-btn-hover-blue cmn-btn-28 j-edit-link\" style=\"display: inline-block;\"><em class=\"cmn-icon wiki-lemma-icons wiki-lemma-icons_edit-lemma\"></em>编辑</a></p></li></ul><p>本词条由<a href=\"http://www.cast.org.cn\" target=\"_blank\" class=\"nslog:7175\">“科普中国”百科科学词条编写与应用工作项目</a>审核\r\n。</p><p>红黑树（Red Black Tree） 是一种自平衡二叉查找树，是在<a target=\"_blank\" href=\"https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA\">计算机</a>科学中用到的一种<a target=\"_blank\" href=\"https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84\">数据结构</a>，典型的用途是实现<a target=\"_blank\" href=\"https://baike.baidu.com/item/%E5%85%B3%E8%81%94%E6%95%B0%E7%BB%84\">关联数组</a>。</p><p>它是在1972年由Rudolf Bayer发明的，当时被称为平衡二叉B树（symmetric binary B-trees）。后来，在1978年被 Leo J. Guibas 和 Robert Sedgewick 修改为如今的“红黑树”。</p><p>红黑树和AVL树类似，都是在进行插入和删除操作时通过特定操作保持二叉查找树的平衡，从而获得较高的查找性能。</p><p>它虽然是复杂的，但它的最坏情况运行时间也是非常良好的，并且在实践中是高效的： 它可以在O(log n)时间内做查找，插入和删除，这里的n 是树中元素的数目。</p><ul class=\"basicInfo-block basicInfo-left list-paddingleft-2\"><li><p>中文名</p></li><li><p>红黑树</p></li><li><p>外文名</p></li><li><p>RED BLACK TREE</p></li><li><p>性&nbsp;&nbsp;&nbsp;&nbsp;质</p></li><li><p>自平衡二叉查找树</p></li></ul><ul class=\"basicInfo-block basicInfo-right list-paddingleft-2\"><li><p>用&nbsp;&nbsp;&nbsp;&nbsp;途</p></li><li><p>实现<a target=\"_blank\" href=\"https://baike.baidu.com/item/%E5%85%B3%E8%81%94%E6%95%B0%E7%BB%84\">关联数组</a></p></li><li><p>发明人</p></li><li><p>鲁道夫·贝尔</p></li><li><p>发明时间</p></li><li><p>1972年</p></li><li><p>别&nbsp;&nbsp;&nbsp;&nbsp;名</p></li><li><p>对称二叉B树</p></li></ul><h2 class=\"block-title\">目录</h2><ol class=\" list-paddingleft-2\"><li><p><span class=\"index\">1</span><span class=\"text\"><a href=\"https://baike.baidu.com/item/%E7%BA%A2%E9%BB%91%E6%A0%91/2413209?fr=aladdin#1\">数据结构</a></span></p></li><li><p><span class=\"index\">2</span><span class=\"text\"><a href=\"https://baike.baidu.com/item/%E7%BA%A2%E9%BB%91%E6%A0%91/2413209?fr=aladdin#2\">树的旋转</a></span></p></li></ol><ol class=\" list-paddingleft-2\"><li><p><span class=\"index\">3</span><span class=\"text\"><a href=\"https://baike.baidu.com/item/%E7%BA%A2%E9%BB%91%E6%A0%91/2413209?fr=aladdin#3\">性质</a></span></p></li><li><p><span class=\"index\">4</span><span class=\"text\"><a href=\"https://baike.baidu.com/item/%E7%BA%A2%E9%BB%91%E6%A0%91/2413209?fr=aladdin#4\">术语</a></span></p></li></ol><ol class=\" list-paddingleft-2\"><li><p><span class=\"index\">5</span><span class=\"text\"><a href=\"https://baike.baidu.com/item/%E7%BA%A2%E9%BB%91%E6%A0%91/2413209?fr=aladdin#5\">用途</a></span></p></li><li><p><span class=\"index\">6</span><span class=\"text\"><a href=\"https://baike.baidu.com/item/%E7%BA%A2%E9%BB%91%E6%A0%91/2413209?fr=aladdin#6\">操作</a></span></p></li></ol><p><a name=\"1\"></a><a name=\"sub133754_1\"></a><a name=\"数据结构\"></a></p><h2 class=\"title-text\">数据结构</h2><p>它的统计性能要好于<a target=\"_blank\" href=\"https://baike.baidu.com/item/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91\">平衡二叉树</a>(有些书籍根</p><p><a class=\"image-link\" href=\"https://baike.baidu.com/pic/%E7%BA%A2%E9%BB%91%E6%A0%91/2413209/0/8cf0d513af89ac60dc540106?fr=lemma&amp;ct=single\" target=\"_blank\" title=\"红黑树\" style=\"width:250px;height:105px;\"><img class=\"\" src=\"https://gss2.bdstatic.com/-fo3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D250/sign=d00e707ab6003af349badb65052bc619/e4dde71190ef76c641326b589d16fdfaae5167e5.jpg\" alt=\"红黑树\" style=\"width:250px;height:105px;\"/></a><span class=\"description\">红黑树</span></p><p>据作者姓名，Adelson-Velskii和Landis，将其称为AVL-树)，因此，红黑树在很多地方都有应用。在C++ \r\nSTL中，很多部分(包括set, multiset, map, multimap)应用了红黑树的变体(SGI \r\nSTL中的红黑树有一些变化，这些修改提供了更好的性能，以及对set操作的支持)。其他<a target=\"_blank\" href=\"https://baike.baidu.com/item/%E5%B9%B3%E8%A1%A1%E6%A0%91\">平衡树</a>还有：<a target=\"_blank\" href=\"https://baike.baidu.com/item/AVL\">AVL</a>，<a target=\"_blank\" href=\"https://baike.baidu.com/item/SBT\">SBT</a>，<a target=\"_blank\" href=\"https://baike.baidu.com/item/%E4%BC%B8%E5%B1%95%E6%A0%91\">伸展树</a>，<a target=\"_blank\" href=\"https://baike.baidu.com/item/TREAP\">TREAP</a> 等等。</p><p><a name=\"2\"></a><a name=\"sub133754_2\"></a><a name=\"树的旋转\"></a></p><h2 class=\"title-text\">树的旋转</h2><p>当我们在对红黑树进行插入和删除等操作时，对树做了修改，那么可能会违背红黑树的性<a class=\"lemma-album layout-right nslog:10000206\" title=\"树的左旋\" href=\"https://baike.baidu.com/pic/%E7%BA%A2%E9%BB%91%E6%A0%91/2413209/16580503/86d6277f9e2f0708cdb73039ed24b899a901f25d?fr=lemma&amp;ct=cover\" target=\"_blank\" style=\"width:222px;\"></a></p><p><a class=\"lemma-album layout-right nslog:10000206\" title=\"树的左旋\" href=\"https://baike.baidu.com/pic/%E7%BA%A2%E9%BB%91%E6%A0%91/2413209/16580503/86d6277f9e2f0708cdb73039ed24b899a901f25d?fr=lemma&amp;ct=cover\" target=\"_blank\" style=\"width:222px;\"><img class=\"picture\" alt=\"树的左旋\" src=\"https://gss1.bdstatic.com/-vo3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D220/sign=ea3c202d46a7d933bba8e3719d4ad194/86d6277f9e2f0708cdb73039ed24b899a901f25d.jpg\" style=\"width:220px;height:146px;\"/></a></p><p><a class=\"lemma-album layout-right nslog:10000206\" title=\"树的左旋\" href=\"https://baike.baidu.com/pic/%E7%BA%A2%E9%BB%91%E6%A0%91/2413209/16580503/86d6277f9e2f0708cdb73039ed24b899a901f25d?fr=lemma&amp;ct=cover\" target=\"_blank\" style=\"width:222px;\">树的左旋<span class=\"number\">(2张)</span></a></p><p>质。</p><p></p><p>为了保持红黑树的性质，我们可以通过对树进行旋转，即修改树中某些结点的颜色及指针结构，以达到对红黑树进行插入、删除结点等操作时，红黑树依然能保持它特有的性质（五点性质）。</p><p>如右图。</p><p><a name=\"3\"></a><a name=\"sub133754_3\"></a><a name=\"性质\"></a></p><h2 class=\"title-text\">性质</h2><p>红黑树是每个节点都带有颜色属性的二叉查找树，颜色或红色或黑色。在二叉查找树强制一般要求以外，对于任何有效的红黑树我们增加了如下的额外要求:</p><p>性质1. 节点是红色或黑色。</p><p>性质2. 根节点是黑色。</p><p>性质3 每个叶节点（NIL节点，空节点）是黑色的。</p><p>性质4 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)</p><p>性质5. 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。</p><p>这些约束强制了红黑树的关键性质: \r\n从根到叶子的最长的可能路径不多于最短的可能路径的两倍长。结果是这个树大致上是平衡的。因为操作比如插入、删除和查找某个值的最坏情况时间都要求与树的高度成比例，这个在高度上的理论上限允许红黑树在最坏情况下都是高效的，而不同于普通的二叉查找树。</p><p>要知道为什么这些特性确保了这个结果，注意到性质4导致了路径不能有两个毗连的红色节点就足够了。最短的可能路径都是黑色节点，最长的可能路径有交替的红色和黑色节点。因为根据性质5所有最长的路径都有相同数目的黑色节点，这就表明了没有路径能多于任何其他路径的两倍长。</p><p>在很多树<a target=\"_blank\" href=\"https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84\">数据结构</a>的表示中，一个节点有可能只有一个子节点，而<a target=\"_blank\" href=\"https://baike.baidu.com/item/%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9\">叶子节点</a>不包含数据。用这种范例表示红黑树是可能的，但是这会改变一些属性并使算法复杂。为此，本文中我们使用\r\n &quot;nil 叶子&quot; \r\n或&quot;空(null)叶子&quot;，如上图所示，它不包含数据而只充当树在此结束的指示。这些节点在绘图中经常被省略，导致了这些树好象同上述原则相矛盾，而实际上不是这样。与此有关的结论是所有节点都有两个子节点，尽管其中的一个或两个可能是空叶子。</p><p><a name=\"4\"></a><a name=\"sub133754_4\"></a><a name=\"术语\"></a></p><h2 class=\"title-text\">术语</h2><p>红黑树是一种特定类型的<a target=\"_blank\" href=\"https://baike.baidu.com/item/%E4%BA%8C%E5%8F%89%E6%A0%91\">二叉树</a>，它是在计算机科学中用来组织数据比如数字的块的一种结构。所有<a target=\"_blank\" href=\"https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%9D%97\">数据块</a>都存储在<a target=\"_blank\" href=\"https://baike.baidu.com/item/%E8%8A%82%E7%82%B9\">节点</a>中。这些节点中的某一个节点总是担当起始位置的功能，它不是任何节点的儿子，我们称之为根节点或根。它有最多两个&quot;儿子&quot;，都是它连接到的其他节点。所有这些儿子都可以有自己的儿子，以此类推。这样根节点就有了把它连接到在树中任何其他节点的路径。</p><p>如果一个节点没有儿子，我们称之为<a target=\"_blank\" href=\"https://baike.baidu.com/item/%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9\">叶子节点</a>，因为在直觉上它是在树的边缘上。子树是从特定<a target=\"_blank\" href=\"https://baike.baidu.com/item/%E8%8A%82%E7%82%B9\">节点</a>可以延伸到的树的某一部分，其自身被当作一个树。在红黑树中，叶子被假定为 null 或空。</p><p>由于红黑树也是二叉查找树，它们当中每一个节点的比较值都必须大于或等于在它的左子树中的所有节点，并且小于或等于在它的右子树中的所有节点。这确保红黑树运作时能够快速的在树中查找给定的值。</p><p><a name=\"5\"></a><a name=\"sub133754_5\"></a><a name=\"用途\"></a></p><h2 class=\"title-text\">用途</h2><p>红黑树和AVL树一样都对插入时间、删除时间和查找时间提供了最好可能的最坏情况担保。这不只是使它们在时间敏感的应用如即时应用(real time application)中有价值，而且使它们有在提供最坏情况担保的其他<a target=\"_blank\" href=\"https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84\">数据结构</a>中作为建造板块的价值；例如，在计算几何中使用的很多数据结构都可以基于红黑树。</p><p>红黑树在<a target=\"_blank\" href=\"https://baike.baidu.com/item/%E5%87%BD%E6%95%B0\">函数</a>式<a target=\"_blank\" href=\"https://baike.baidu.com/item/%E7%BC%96%E7%A8%8B\">编程</a>中也特别有用，在这里它们是最常用的持久<a target=\"_blank\" href=\"https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84\">数据结构</a>之一，它们用来构造<a target=\"_blank\" href=\"https://baike.baidu.com/item/%E5%85%B3%E8%81%94%E6%95%B0%E7%BB%84\">关联数组</a>和集合，在突变之后它们能保持为以前的版本。除了O(log n)的时间之外，红黑树的持久版本对每次插入或删除需要O(log n)的空间。</p><p>红黑树是 <a target=\"_blank\" href=\"https://baike.baidu.com/item/2-3-4%E6%A0%91\">2-3-4树</a>的一种等同。换句话说，对于每个 2-3-4 树，都存在至少一个<a target=\"_blank\" href=\"https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%85%83%E7%B4%A0\">数据元素</a>是同样次序的红黑树。在 2-3-4 树上的插入和删除操作也等同于在红黑树中颜色翻转和旋转。这使得 2-3-4 树成为理解红黑树背后的逻辑的重要工具，这也是很多介绍算法的教科书在红黑树之前介绍 2-3-4 树的原因，尽管 2-3-4 树在实践中不经常使用。</p><p><a name=\"6\"></a><a name=\"sub133754_6\"></a><a name=\"操作\"></a></p><h2 class=\"title-text\">操作</h2><p>在红黑树上只读操作不需要对用于二叉查找树的操作做出修改，因为它也是二叉查找树。但是，在插入和删除之后，红黑属性可能变得违规。恢复红黑属性需要少量(O(log n))的颜色变更(这在实践中是非常快速的)并且不超过三次<a target=\"_blank\" href=\"https://baike.baidu.com/item/%E6%A0%91%E6%97%8B%E8%BD%AC\">树旋转</a>(对于插入是两次)。这允许插入和删除保持为 O(log n) 次，但是它导致了非常复杂的操作。<sup>[1]</sup><a name=\"ref_[1]_133754\"></a>&nbsp;</p><p><br/></p>', '20171129\\e2151f8e93c51f1dcd5372fb907951fb.jpg', '1', '2017-11-28');
INSERT INTO `run_article` VALUES ('14', '17', 'wang ', 'MR:DALY', 'fasdfasdfsd', '<p><img src=\"/thinkphp5.0/public/upload/temp/2017/11-28/a536404971c2be216f8451a43206f65c.jpg\"/></p><p><img src=\"/thinkphp5.0/public/upload/temp/2017/11-28/a3b02c54ef069e3f70f5d0414c391a20.jpg\"/></p><p><img src=\"/thinkphp5.0/public/upload/temp/2017/11-28/94d3a0ef480bf2a3ea11774e91b7e0bf.jpg\"/></p><p><img src=\"/thinkphp5.0/public/upload/temp/2017/11-28/88fa0924d56143319e4d40123b097ec3.jpg\"/></p><p><img src=\"/thinkphp5.0/public/upload/temp/2017/11-28/8315eb5b557c287f39ce51356b43d2db.jpg\"/></p><p><img src=\"/thinkphp5.0/public/upload/temp/2017/11-28/6dbbb7912371597b5764ccc8272e87bc.jpg\"/></p><p><img src=\"/thinkphp5.0/public/upload/temp/2017/11-28/526e6d0b88bf10107ac1ef65ac7ba8e7.jpg\"/></p><p><br/></p>', '20171129\\c458c05a2da5895cb0df603bf97ce4cd.jpg', '1', '2017-11-28');
INSERT INTO `run_article` VALUES ('16', '17', '解递归之php递归', 'MR:DALY', '下面说一个场景，斐波纳契数列：1,      1,      2,      3,      5,      8,      13,   21,   34,  ', '<p><span style=\"color: #000000; font-family: 微软雅黑; font-size: 18px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px; display: inline !important; float: none;\">已知前两项的和，求第三项的和，因为重复用到这个方法，所以用到递归去解：<br/></span></p><p><span style=\"color: #000000; font-family: 微软雅黑; font-size: 18px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px; display: inline !important; float: none;\">斐波那契数列的规律是当前项等于前两项的和，得到的公式是f(n)=f(n-1)+f(n-2);这里的n表示第几项，上递归代码：<br/></span></p><p><span style=\"color: #000000; font-family: 微软雅黑; font-size: 18px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px; display: inline !important; float: none;\">这里假设子问题已经解决，加入求第10项的值公式为：f(10)=f(9)+f(8)故而出现上面的公式</span></p><p><img src=\"/thinkphp5.0/public/upload/temp/2017/11-29/fbae6b5400a369d0e7e5ef6dcaf9fd50.png\" title=\"fbae6b5400a369d0e7e5ef6dcaf9fd50.png\" alt=\"fbae6b5400a369d0e7e5ef6dcaf9fd50.png\"/></p>', '20171129\\5e779291320dd9c2f7f8bed09d3ac80a.jpg', '1', '2017-11-29');
INSERT INTO `run_article` VALUES ('17', '17', '已读的形式输出字符串', 'MR:DALY', '1个字符串用读出的形式输出，\r\n利用preg_replace_callback（）函数', '<p style=\"text-align:center\"><br/></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br/></p><pre style=\"background-color:#2b2b2b;color:#a9b7c6;font-family:&#39;宋体&#39;;font-size:12.0pt;\"><span style=\"color:#629755;background-color:#232525;font-style:italic;\">/**<br/></span><span style=\"color:#629755;background-color:#232525;font-style:italic;\"> * Created by PhpStorm.<br/></span><span style=\"color:#629755;background-color:#232525;font-style:italic;\"> * User:MR:Dailey<br/></span><span style=\"color:#629755;background-color:#232525;font-style:italic;\"> * Weixin-tel:18665585707<br/></span><span style=\"color:#629755;background-color:#232525;font-style:italic;\"> * Date: 2017/11/17<br/></span><span style=\"color:#629755;background-color:#232525;font-style:italic;\"> * Time: 17:02<br/></span><span style=\"color:#629755;background-color:#232525;font-style:italic;\"> */<br/> <br/> 已读的形式输出字符串：<br/> &nbsp;例子：<br/> &nbsp; &nbsp;① 18665585707 读1个1,1个8,2个6,2个5,1个8,1个5,1个7,1个0,1个7 答案：111826251815171017<br/> &nbsp; &nbsp;② 520 读1个5,1个2,1个0 答案：151210<br/> <br/></span><span style=\"color:#cc7832;background-color:#232525;font-weight:bold;\">function </span><span style=\"color:#ffc66d;background-color:#232525;\">lookAndSay</span><span style=\"background-color:#232525;\">(</span><span style=\"color:#9876aa;background-color:#232525;\">$str</span><span style=\"background-color:#232525;\">) {<br/></span><span style=\"background-color:#232525;\"> &nbsp; &nbsp;</span><span style=\"color:#cc7832;background-color:#232525;font-weight:bold;\">return </span><span style=\"background-color:#232525;\">preg_replace_callback(<br/></span><span style=\"background-color:#232525;\"> &nbsp; &nbsp; &nbsp; &nbsp;</span><span style=\"color:#6a8759;background-color:#232525;\">&#39;/(.)\\1*/u&#39;</span><span style=\"color:#cc7832;background-color:#232525;\">,<br/></span><span style=\"color:#cc7832;background-color:#232525;\"> &nbsp; &nbsp; &nbsp; &nbsp;</span><span style=\"color:#cc7832;background-color:#232525;font-weight:bold;\">function</span><span style=\"background-color:#232525;\">(</span><span style=\"color:#9876aa;background-color:#232525;\">$match</span><span style=\"background-color:#232525;\">) {<br/></span><span style=\"background-color:#232525;\"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span style=\"color:#cc7832;background-color:#232525;font-weight:bold;\">return </span><span style=\"background-color:#232525;\">strlen(</span><span style=\"color:#9876aa;background-color:#232525;\">$match</span><span style=\"background-color:#232525;\">[</span><span style=\"color:#6897bb;background-color:#232525;\">0</span><span style=\"background-color:#232525;\">]).</span><span style=\"color:#9876aa;background-color:#232525;\">$match</span><span style=\"background-color:#232525;\">[</span><span style=\"color:#6897bb;background-color:#232525;\">1</span><span style=\"background-color:#232525;\">]</span><span style=\"color:#cc7832;background-color:#232525;\">;<br/></span><span style=\"color:#cc7832;background-color:#232525;\"> &nbsp; &nbsp; &nbsp; &nbsp;</span><span style=\"background-color:#232525;\">}</span><span style=\"color:#cc7832;background-color:#232525;\">,<br/></span><span style=\"color:#cc7832;background-color:#232525;\"> &nbsp; &nbsp; &nbsp; &nbsp;</span><span style=\"color:#9876aa;background-color:#232525;\">$str<br/></span><span style=\"color:#9876aa;background-color:#232525;\"> &nbsp; &nbsp;</span><span style=\"background-color:#232525;\">)</span><span style=\"color:#cc7832;background-color:#232525;\">;<br/></span><span style=\"background-color:#232525;\">}<br/></span><span style=\"color:#9876aa;background-color:#232525;\">$str </span><span style=\"background-color:#232525;\">= </span><span style=\"color:#6897bb;background-color:#232525;\">111244233</span><span style=\"color:#cc7832;background-color:#232525;\">;<br/></span><span style=\"color:#cc7832;background-color:#232525;font-weight:bold;\">echo </span><span style=\"background-color:#232525;\">lookAndSay(</span><span style=\"color:#9876aa;background-color:#232525;\">$str</span><span style=\"background-color:#232525;\">)</span><span style=\"color:#cc7832;background-color:#232525;\">;<br/></span></pre><p><br/></p>', '20171129\\b65a0c8742fa35d1d58f9cc81f39c3e5.jpg', '1', '2017-11-29');
